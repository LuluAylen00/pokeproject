import * as T from '@pkmn/dex-types';
export { AbilityData, AbilityName, As, BoostID, BoostsTable, ConditionData, Data, DataKind, Effect, EffectData, EffectType, EggGroup, EventInfo, EventInfoData, EvoType, FieldCondition, FormeName, GameType, GenID, GenderName, GenerationNum, HPColor, HPTypeName, HitEffect, ID, ItemData, ItemName, LearnsetData, MoveCategory, MoveData, MoveName, MoveSource, MoveTarget, NatureData, NatureName, Nonstandard, Player, PokemonSet, SecondaryEffect, SideCondition, SideID, SpeciesData, SpeciesName, StatID, StatsTable, StatusName, Tier, TypeData, TypeName, Weather } from '@pkmn/dex-types';

declare function toID(text: any): T.ID;
interface FormatData {
    tier?: string;
    doublesTier?: string;
    isNonstandard?: T.Nonstandard;
    inherit?: boolean;
}
interface AnyObject {
    [k: string]: any;
}
declare class BasicEffect<NameT extends string = string> implements T.BasicEffect<NameT> {
    id: T.ID;
    name: NameT;
    fullname: string;
    effectType: T.EffectType;
    kind: T.DataKind;
    exists: boolean;
    num: number;
    gen: T.GenerationNum;
    shortDesc: string;
    desc: string;
    isNonstandard: T.Nonstandard | null;
    duration?: number;
    constructor(data: AnyObject);
    toString(): NameT;
}
declare class Condition extends BasicEffect implements T.Condition {
    readonly effectType: 'Condition' | 'Weather' | 'Status' | 'Terastal';
    readonly kind: 'Condition';
    constructor(data: AnyObject);
}
declare class DexConditions implements T.DexTable<Condition> {
    readonly dex: ModdedDex;
    readonly cache: {
        [id: string]: Condition;
    };
    constructor(dex: ModdedDex);
    get(name: string): Condition;
    getByID(id: T.ID): Condition;
}
declare class Ability extends BasicEffect<T.AbilityName> implements T.Ability {
    readonly effectType: 'Ability';
    readonly kind: 'Ability';
    readonly isBreakable?: boolean;
    readonly suppressWeather?: boolean;
    readonly condition?: Partial<Condition>;
    constructor(data: AnyObject);
}
declare class DexAbilities implements T.DexTable<Ability> {
    readonly dex: ModdedDex;
    readonly caches: {
        get: {
            [id: string]: Ability;
        };
        all: readonly Ability[] | undefined;
    };
    constructor(dex: ModdedDex);
    get(name: string): Ability;
    getByID(id: T.ID): Ability;
    all(): readonly Ability[];
}
declare class Item extends BasicEffect<T.ItemName> implements T.Item {
    readonly effectType: 'Item';
    readonly kind: 'Item';
    readonly forcedForme?: T.SpeciesName;
    readonly megaStone?: T.SpeciesName;
    readonly megaEvolves?: T.SpeciesName;
    readonly onDrive?: T.TypeName;
    readonly onMemory?: T.TypeName;
    readonly onPlate?: T.TypeName;
    readonly zMove?: T.MoveName | true;
    readonly zMoveType?: T.TypeName;
    readonly zMoveFrom?: T.MoveName;
    readonly itemUser?: T.SpeciesName[];
    readonly fling?: T.ItemData['fling'];
    readonly condition?: Partial<Condition>;
    readonly ignoreKlutz?: boolean;
    readonly isBerry?: boolean;
    readonly isChoice?: boolean;
    readonly isGem?: boolean;
    readonly isPokeball?: boolean;
    readonly naturalGift?: {
        basePower: number;
        type: T.TypeName;
    };
    readonly boosts?: Partial<T.BoostsTable> | false;
    constructor(data: AnyObject);
}
declare class DexItems implements T.DexTable<Item> {
    readonly dex: ModdedDex;
    readonly caches: {
        get: {
            [id: string]: Item;
        };
        all: readonly Item[] | undefined;
    };
    constructor(dex: ModdedDex);
    get(name?: string): Item;
    getByID(id: T.ID): Item;
    all(): readonly Item[];
}
declare class Move extends BasicEffect<T.MoveName> implements T.Move {
    readonly effectType: 'Move';
    readonly kind: 'Move';
    readonly boosts?: Partial<T.BoostsTable>;
    readonly status?: T.StatusName;
    readonly volatileStatus?: T.ID;
    readonly slotCondition?: T.ID;
    readonly sideCondition?: T.ID;
    readonly terrain?: T.ID;
    readonly pseudoWeather?: T.ID;
    readonly weather?: T.ID;
    readonly basePower: number;
    readonly type: T.TypeName;
    readonly accuracy: true | number;
    readonly pp: number;
    readonly target: T.MoveTarget;
    readonly priority: number;
    readonly flags: T.Move['flags'];
    readonly category: T.MoveCategory;
    readonly condition?: Partial<T.Condition>;
    readonly damage?: number | 'level' | false | null;
    readonly noPPBoosts?: boolean;
    readonly isZ: boolean | T.ID;
    readonly zMove?: {
        basePower?: number;
        effect?: T.ID;
        boost?: Partial<T.BoostsTable>;
    };
    readonly isMax: boolean | T.SpeciesName;
    readonly maxMove?: {
        basePower: number;
    };
    readonly ohko?: boolean | T.TypeName;
    readonly thawsTarget?: boolean;
    readonly heal?: number[] | null;
    readonly forceSwitch?: boolean;
    readonly selfSwitch?: 'copyvolatile' | 'shedtail' | boolean;
    readonly selfBoost?: {
        boosts?: Partial<T.BoostsTable>;
    };
    readonly selfdestruct?: boolean | 'ifHit' | 'always';
    readonly breaksProtect?: boolean;
    readonly recoil?: [number, number];
    readonly drain?: [number, number];
    readonly mindBlownRecoil?: boolean;
    readonly struggleRecoil?: boolean;
    readonly stealsBoosts?: boolean;
    readonly secondary?: T.SecondaryEffect | null;
    readonly secondaries: T.SecondaryEffect[] | null;
    readonly self?: T.HitEffect | null;
    readonly alwaysHit?: boolean;
    readonly basePowerModifier?: number;
    readonly critModifier?: number;
    readonly critRatio?: number;
    readonly overrideOffensivePokemon?: 'target' | 'source';
    readonly overrideOffensiveStat?: Exclude<T.StatID, 'hp'>;
    readonly overrideDefensivePokemon?: 'target' | 'source';
    readonly overrideDefensiveStat?: Exclude<T.StatID, 'hp'>;
    readonly forceSTAB?: boolean;
    readonly ignoreAbility?: boolean;
    readonly ignoreAccuracy?: boolean;
    readonly ignoreDefensive?: boolean;
    readonly ignoreEvasion?: boolean;
    readonly ignoreImmunity?: boolean | {
        [k in keyof T.TypeName]?: boolean;
    };
    readonly ignoreNegativeOffensive?: boolean;
    readonly ignoreOffensive?: boolean;
    readonly ignorePositiveDefensive?: boolean;
    readonly ignorePositiveEvasion?: boolean;
    readonly infiltrates?: boolean;
    readonly orderUpBoost?: boolean;
    readonly multiaccuracy?: boolean;
    readonly multihit?: number | number[];
    readonly noCopy?: boolean;
    readonly noDamageVariance?: boolean;
    readonly noFaint?: boolean;
    readonly nonGhostTarget?: T.MoveTarget;
    readonly pressureTarget?: T.MoveTarget;
    readonly sleepUsable?: boolean;
    readonly smartTarget?: boolean;
    readonly spreadModifier?: number;
    readonly tracksTarget?: boolean;
    readonly willCrit?: boolean;
    readonly hasCrashDamage?: boolean;
    readonly hasSheerForce?: boolean;
    readonly isConfusionSelfHit?: boolean;
    readonly isFutureMove?: boolean;
    readonly noMetronome?: T.MoveName[];
    readonly noSketch?: boolean;
    readonly stallingMove?: boolean;
    constructor(data: AnyObject);
}
declare class DexMoves implements T.DexTable<Move> {
    readonly dex: ModdedDex;
    readonly caches: {
        get: {
            [id: string]: Move;
        };
        all: readonly Move[] | undefined;
    };
    constructor(dex: ModdedDex);
    get(name: string): Move;
    getByID(id: T.ID): Move;
    all(): readonly Move[];
}
declare class Nature extends BasicEffect<T.NatureName> implements T.Nature {
    readonly effectType: 'Nature';
    readonly kind: 'Nature';
    readonly plus?: Exclude<T.StatID, 'hp'>;
    readonly minus?: Exclude<T.StatID, 'hp'>;
    constructor(data: AnyObject);
}
declare class DexNatures implements T.DexTable<Nature> {
    readonly dex: ModdedDex;
    readonly caches: {
        get: {
            [id: string]: Nature;
        };
        all: readonly Nature[] | undefined;
    };
    constructor(dex: ModdedDex);
    get(name: string): Nature;
    getByID(id: T.ID): Nature;
    all(): readonly Nature[];
}
declare class Species extends BasicEffect<T.SpeciesName> implements T.Species {
    readonly effectType: 'Pokemon';
    readonly kind: 'Species';
    readonly baseStats: T.StatsTable;
    readonly bst: number;
    readonly baseSpecies: T.SpeciesName;
    readonly baseForme: T.FormeName | '';
    readonly forme: T.FormeName | '';
    readonly abilities: T.SpeciesAbility<T.AbilityName | ''>;
    readonly types: [T.TypeName] | [T.TypeName, T.TypeName];
    readonly prevo?: T.SpeciesName | '';
    readonly evos?: T.SpeciesName[];
    readonly nfe: boolean;
    readonly eggGroups: T.EggGroup[];
    readonly canHatch: boolean;
    readonly weightkg: number;
    readonly weighthg: number;
    readonly tags: T.SpeciesTag[];
    readonly unreleasedHidden: boolean | 'Past';
    readonly maleOnlyHidden: boolean;
    readonly changesFrom?: T.SpeciesName;
    readonly tier: T.Tier.Singles | T.Tier.Other | 'Illegal';
    readonly doublesTier: T.Tier.Doubles | 'Illegal';
    readonly cosmeticFormes?: T.SpeciesName[];
    readonly otherFormes?: T.SpeciesName[];
    readonly formeOrder?: T.SpeciesName[];
    readonly genderRatio: {
        M: number;
        F: number;
    };
    readonly isMega?: boolean;
    readonly isPrimal?: boolean;
    readonly battleOnly?: T.SpeciesName | T.SpeciesName[];
    readonly canGigantamax?: T.MoveName;
    readonly gmaxUnreleased?: boolean;
    readonly cannotDynamax?: boolean;
    readonly requiredAbility?: T.AbilityName;
    readonly requiredItem?: T.ItemName;
    readonly requiredItems?: T.ItemName[];
    readonly requiredMove?: T.MoveName;
    readonly gender?: T.GenderName;
    readonly maxHP?: number;
    readonly evoMove?: T.MoveName;
    readonly evoItem?: string;
    readonly evoRegion?: 'Alola' | 'Galar';
    readonly evoLevel?: number;
    readonly evoCondition?: string;
    readonly evoType?: T.EvoType;
    readonly condition?: Partial<Condition>;
    constructor(data: AnyObject);
}
declare class DexSpecies implements T.DexTable<Species> {
    readonly dex: ModdedDex;
    readonly caches: {
        get: {
            [id: string]: Species;
        };
        all: readonly Species[] | undefined;
    };
    constructor(dex: ModdedDex);
    get(name: string): Species;
    getByID(id: T.ID): Species;
    all(): readonly Species[];
}
declare class Learnset implements T.Learnset {
    readonly effectType: 'Learnset';
    readonly kind: 'Learnset';
    readonly learnset?: {
        [moveid: string]: T.MoveSource[];
    };
    readonly eventOnly: boolean;
    readonly eventData?: T.EventInfo[];
    readonly encounters?: T.EventInfo[];
    readonly exists: boolean;
    constructor(data: AnyObject);
}
declare class DexLearnsets {
    readonly dex: ModdedDex;
    readonly cache: {
        [id: string]: Learnset;
    };
    constructor(dex: ModdedDex);
    get(name: string): Promise<Learnset>;
    getByID(id: T.ID): Promise<Learnset>;
}
declare class Type implements T.Type {
    readonly id: T.ID;
    readonly name: T.TypeName;
    readonly effectType: 'Type';
    readonly kind: 'Type';
    readonly exists: boolean;
    readonly gen: T.GenerationNum;
    readonly isNonstandard: T.Nonstandard | null;
    readonly damageTaken: {
        [t in Exclude<T.TypeName, '???'>]: number;
    } & {
        [key: string]: number;
    };
    readonly HPivs: Partial<T.StatsTable>;
    readonly HPdvs: Partial<T.StatsTable>;
    constructor(data: AnyObject);
    toString(): T.TypeName;
}
declare class DexTypes implements T.DexTable<Type> {
    readonly dex: ModdedDex;
    readonly caches: {
        get: {
            [id: string]: Type;
        };
        all: readonly Type[] | undefined;
        names: readonly string[] | undefined;
    };
    constructor(dex: ModdedDex);
    get(name: string): Type;
    getByID(id: T.ID): Type;
    names(): readonly string[];
    isName(name: string): boolean;
    all(): readonly Type[];
}
declare const STATS: readonly T.StatID[];
declare class DexStats {
    readonly shortNames: {
        readonly [k in T.StatID]: string;
    };
    readonly mediumNames: {
        readonly [k in T.StatID]: string;
    };
    readonly names: {
        readonly [k in T.StatID]: string;
    };
    constructor(dex: ModdedDex);
    ids(): typeof STATS;
}
declare const GEN_IDS: readonly ["gen1", "gen2", "gen3", "gen4", "gen5", "gen6", "gen7", "gen8", "gen9"];
type GenID = typeof GEN_IDS[number];
type ModData = T.DeepPartial<ModdedDex['data']> & T.ModData;
declare class ModdedDex implements T.Dex {
    static readonly STATS: ReadonlyArray<T.StatID>;
    readonly gen: T.GenerationNum;
    readonly modid: T.ID;
    readonly data: {
        Abilities: {
            [id: string]: T.AbilityData;
        };
        Aliases: {
            [id: string]: string;
        };
        Conditions: {
            [id: string]: T.ConditionData;
        };
        FormatsData: {
            [id: string]: FormatData;
        };
        Items: {
            [id: string]: T.ItemData;
        };
        Learnsets: null | {
            [id: string]: T.LearnsetData;
        };
        Moves: {
            [id: string]: T.MoveData;
        };
        Natures: {
            [id: string]: T.NatureData;
        };
        Species: {
            [id: string]: T.SpeciesData;
        };
        Types: {
            [id: string]: T.TypeData;
        };
    };
    readonly abilities: DexAbilities;
    readonly conditions: DexConditions;
    readonly items: DexItems;
    readonly learnsets: DexLearnsets;
    readonly moves: DexMoves;
    readonly natures: DexNatures;
    readonly species: DexSpecies;
    readonly stats: DexStats;
    readonly types: DexTypes;
    modData?: ModData;
    constructor(modid?: T.ID | "gen1" | "gen2" | "gen3" | "gen4" | "gen5" | "gen6" | "gen7" | "gen8" | "gen9", modData?: ModData);
    mod(genid: GenID): ModdedDex;
    mod(modid: T.ID, modData: ModData): ModdedDex;
    forGen(gen: number): ModdedDex;
    getImmunity(source: {
        type: string;
    } | string, target: {
        getTypes: () => string[];
    } | {
        types: string[];
    } | string[] | string): boolean;
    getEffectiveness(source: {
        type: string;
    } | string, target: {
        getTypes: () => string[];
    } | {
        types: string[];
    } | string[] | string): number;
    getHiddenPower(ivs: T.StatsTable): {
        type: T.HPTypeName;
        power: number;
    };
    includeModData(): this;
    includeData(): this;
    includeFormats(): this;
    loadData(modData?: ModData): {
        Abilities: {
            [id: string]: T.AbilityData;
        };
        Aliases: {
            [id: string]: string;
        };
        Conditions: {
            [id: string]: T.ConditionData;
        };
        FormatsData: {
            [id: string]: FormatData;
        };
        Items: {
            [id: string]: T.ItemData;
        };
        Learnsets: {
            [id: string]: T.LearnsetData;
        } | null;
        Moves: {
            [id: string]: T.MoveData;
        };
        Natures: {
            [id: string]: T.NatureData;
        };
        Species: {
            [id: string]: T.SpeciesData;
        };
        Types: {
            [id: string]: T.TypeData;
        };
    };
    load(type: Exclude<keyof ModdedDex['data'], 'Aliases'>, modData?: ModData): void;
}
declare const Dex: ModdedDex;

export { Ability, BasicEffect, Condition, Dex, FormatData, Item, Learnset, ModData, ModdedDex, Move, Nature, Species, Type, toID };
